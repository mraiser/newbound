{"data":{"css":"","data":[],"name":"interpreter","js":"var me = this;\nvar ME = $('#'+me.UUID)[0];\n\nfunction addFunction(obj, name, code){\n  var args = [];\n  for (j in code.params) args.push(code.params[j].name);\n  obj[name] = function(){\n    var params = {};\n    for (j in args) params[args[j]] = arguments[j];\n    return execute(obj, deepCopy(code.flow), params);\n  }\n}\nme.addFunction = addFunction;\n\nfunction execute(obj, code, args){\n  var i = 0;\n  var done = false;\n  var out = {};\n  \n  code.FINISHFLAG = false;\n  var currentcase = code;\n  while (true){\n    var cmds = currentcase.cmds;\n    var cons = currentcase.cons;\n    \n    var n = cons.length;\n    var n2 = cmds.length;\n    \n    for (i=0;i<n2;i++){\n      var cmd = cmds[i];\n      if (!cmd.done){\n        var input = cmd.in;\n        if (Object.keys(input).length == 0) evaluate(obj, cmd);\n        else{\n          var b = true;\n          for (var key in input){\n            // input[key].done = false; // FIXME - Java interpreter seems to require this\n            var con = lookupConnection(currentcase, key, \"in\");\n            if (con == null) input[key].done = true;\n            else b = false;\n          }\n          if (b) evaluate(obj, cmd);\n        }\n      }\n    }\n    \n    while (!done){\n      var c = true;\n      \n      for (i = 0; i < n; i++) {\n        var con = cons[i];\n        if (!con.done){\n          c = false;\n          var ja = con.src;\n          var src = ja[0];\n          var srcname = ja[1];\n          ja = con.dest;\n          var dest = ja[0];\n          var destname = ja[1];\n          \n          var b = false;\n          var val;\n          if (src == -1){\n            val = args[srcname];\n            b = true;\n          }\n          else {\n            var cmd = cmds[src];\n            if (cmd.done){\n              var vals = cmd.out;\n              var val = vals[srcname];\n              b = true;\n            }\n          }\n          \n          if (b) {\n            con.done = true;\n            if (dest == -2){\n              out[destname] = val;\n            }\n            else{\n              var cmd = cmds[dest];\n              if (cmd.type == 'undefined'){ // FIXME - is this used?\n                cmd.done = true;\n              }\n              else{\n                var ins = cmd.in;\n                var v = ins[destname];\n                v.val = val;\n                v.done = true;\n                \n                for (var key in ins){\n                  if (!b) break;\n                  var input = ins[key];\n                  b = input.done;\n                }\n                \n                if (b) evaluate(obj, cmd);\n              }\n            }\n          }\n        }\n      }\n        \n      if (c) \n        done = true;\n    }\n    break;\n  }\n  // FIXME - catch next case exception and terminate case exception here\n  \n  return out;\n}\nme.execute = execute;\n\nfunction lookupConnection(currentcase, name, which){\n  var cons = currentcase.cons;\n  for (var i in cons){\n    var con = cons[i];\n    var bar = con[which == 'in' ? 'dest' : 'src'];\n    if (bar[1] == name) return con;\n  }\n  return null;\n}\n\nfunction evaluate(obj, cmd){\n  var in1 = {};\n  var in2 = cmd['in'];\n  var list_in = [];\n  for (var name in in2){\n    var in3 = in2[name];\n    in1[name] = in3.val;\n    if (in3.mode == 'list') list_in.push(name);\n  }\n  \n  var out2 = cmd.out;\n  var list_out = [];\n  var loop_out = [];\n  for (var name in out2){\n    var out3 = out2[name];\n    if (out3.mode){\n      var mode = out3.mode;\n      if (mode == 'list') list_out.push(name);\n      else if (mode == 'loop') loop_out.push(name);\n    }\n  }\n  \n  var n = list_in.length;\n  if (n == 0 && loop_out.length == 0) evaluateOperation(obj, cmd, in1);\n  else{\n    var out3 = {};\n    for (var i=0; i<list_out.length; i++) out3[list_out[i]] = [];\n    var count = 0;\n    if (n>0){\n      count = in1[list_in[0]].length;\n      for (var i = 0; i < n; i++) count = Math.min(count, in1[list_in[0]].length);\n    }\n    \n    var i = 0;\n    while (true){\n      var in3 = {};\n      for (var k in in1){\n        if (list_in.indexOf(k) == -1) in3[k] = in1[k];\n        else{\n          var ja = in1[k];\n          in3[k] = ja[i];\n        }\n      }\n      \n      evaluateOperation(obj, cmd, in3);\n      \n      var out = cmd.out;\n      for (var k in out2){ // FIXME - aren't out & out2 the same thing?\n        var val = out[k];\n        if (list_out.indexOf(k) != -1) out3[k].push(val);\n        else{\n          out3[k] = val;\n          if (loop_out.indexOf(k) != -1){\n            var newk = out2[k][\"loop\"];\n            in1[newk] = val;\n          }\n        }\n      }\n      if (cmd.FINISHED) break;\n      if (n>0){\n        i++;\n        if (i == count) break;\n      }\n    }\n  \n    cmd.out = out3;\n  }\n}\n\nfunction evaluateOperation(obj, cmd, in1){\n  var out = {};\n  var type = cmd.type;\n  var b = false;\n  try{\n    if (type == 'primitive') out = handlePrimitive(cmd, in1);\n    else if (type == 'local'){\n      var code = cmd.localdata;\n      code = deepCopy(code);\n      out = execute(obj, code, in1);\n      cmd.FINISHED = code.FINISHFLAG;\n    }\n    else if (type == 'constant'){\n      out = cmd.out;\n      for (var key in out){\n        var val = cmd.name;\n        var ctype = cmd.ctype;\n        out[key] = forceType(ctype, val);\n      }\n    }\n    else if (type == 'match'){\n      var a = in1[Object.keys(in1)[0]];\n      var ctype = cmd.ctype;\n      var val1 = forceType(ctype, a);\n      var val2 = forceType(ctype, cmd.name);\n      b = val1 === val2;\n      out = {};\n    }\n    else if (type == 'command'){\n      throw new Error(\"Commands not supported\");\n    }\n    else out = {};\n    \n    if (type != 'match') b = true;\n  }\n  catch(x) { // FIXME - should this only catch FailException like java version?\n    cmd.err = x;\n    b = false;\n    out = {};\n    debugger;\n  }\n  finally {\n    if (type != 'constant' && cmd.condition){\n      var condition = cmd.condition;\n      evaluateConditional(condition, b);\n    }\n    else if (!b) throw cmd.err; // Compensate for catching all\n    \n    cmd.out = out;\n    cmd.done = true;\n  }\n}\n\nfunction deepCopy(o){\n  if (Array.isArray(o)){\n    var no = [];\n    for (var i in o) no.push(deepCopy(o[i]));\n    return no;\n  }\n  else if (typeof o == 'object'){\n    var no = {};\n    for (var i in o) no[i] = deepCopy(o[i]);\n    return no;\n  }\n  return o;\n}\n\nfunction forceType(ctype, val){\n  if (typeof val == 'string'){\n    if (ctype == 'int') val = parseInt(val);\n    else if (ctype == 'decimal') val = Number(val);\n    else if (ctype == 'boolean') val = val === 'true';\n    else if (ctype == 'object' || ctype == 'array') val = JSON.parse(val);\n  }\n  else if (ctype == 'string') val = ''+val;\n  return val;\n}\n\nfunction handlePrimitive(cmd, in1){\n  var inkeys = Object.keys(cmd.in);\n  var outkeys = Object.keys(cmd.out);\n  var out = {};\n  \n  if (cmd.name == \"+\") out[outkeys[0]] = in1[inkeys[0]] + in1[inkeys[1]];\n  else\n    throw new Error(\"Unknown primitive: \"+cmd.name);\n  \n  return out;\n}\n","groups":"","ctl":"nzskxq17a96497b37x14","html":"","three":{"controls":[],"assets":[],"behaviors":[],"animations":[],"poses":[]},"db":"flow","desc":""},"id":"nzskxq17a96497b37x14","sessionid":"jvgvwg16b7a4d277bt3","time":1626019360795,"addr":"/0:0:0:0:0:0:0:1:35792","username":"admin"}
{"data":{"css":"","data":[],"name":"node","js":"var me = this;\nvar ME = $('#'+me.UUID)[0];\n\nme.animate = function(model){\n  me.model = model;\n  me.type = \"node\";\n  me.sphere = me.children[0];\n  me.data = ME.DATA;\n  me.checkIcon();\n};\n\nme.render = function(model){\n  var scale = Number(me.sphere.rig.scale_x);\n  var target = me.selected ? 0.2 : 0.15;\n  if (scale != target) {\n    var amt = scale < target ? 0.01 : -0.01;\n    scale += amt;\n    me.sphere.rig.scale_x = me.sphere.rig.scale_y = me.sphere.rig.scale_z = scale;\n    //me.sphere2.rig.scale_x = me.sphere2.rig.scale_y = me.sphere2.rig.scale_z = scale;\n  }\n  var pos = Number(me.sphere.rig.pos_y);\n  target = me.direction == 'src' ? -0.1 : 0.1;\n  if (Math.abs(target - pos)>0.001){\n    var amt = (target - pos) / 10;\n    me.sphere.rig.pos_y = pos + amt;\n    if (me.icon) me.icon.model.rig.pos_y = 3 * (pos + amt);\n  }\n  if (me.line){\n    if (me.target_rot != me.current_rot){\n      me.current_rot = me.target_rot;\n      me.line.rotation.y = me.current_rot;\n      me.line.position.x = Math.sin(me.current_rot) * -20;\n      me.line.position.z = Math.cos(me.current_rot) * -20 + 20;\n    }\n    var pos = me.line.geometry.attributes.position.array[2];// me.line.geometry.vertices[0].z;\n    var target = me.target_z ? me.target_z : 0;\n    if (pos != target) {\n      var amt = pos < target ? 0.5 : -0.5;\n      pos += amt;\n//      me.line.geometry.vertices[0].z = pos;\n//      me.line.geometry.vertices[1].z = pos;\n//      me.line.geometry.verticesNeedUpdate = true;\n      me.line.geometry.attributes.position.array[2] = pos;\n      me.line.geometry.attributes.position.array[5] = pos;\n      me.line.geometry.attributes.position.needsUpdate = true;\n    }\n  }\n  if (me.data.mode == 'loop'){\n    if (typeof me.data.loop == \"string\" && me.parent.parent.inputbar && me.parent.parent.outputbar){\n      var putbar = me.direction == 'src' ? me.parent.parent.inputbar.api : me.parent.parent.outputbar.api;\n      var n = putbar.getNodeByName(me.data.loop)\n      if (n) me.data.loop = n;\n    }\n  }\n};\n\nme.checkIcon = function(){\n  if (me.parent && me.parent.parent.type == \"operation\"){\n    if (!me.data.mode) me.data.mode = \"regular\";\n    if (!me.iconmode) me.iconmode = \"regular\";\n    if (me.iconmode != me.data.mode){\n      me.clearIcon();\n      me.iconmode = me.data.mode;\n      if (me.iconmode != 'regular'){\n        me.addIcon(me.iconmode);\n      }\n    }\n  }\n};\n\nme.clearIcon = function(){\n  if (me.icon) me.model.scene.viewer.removeModel(me.icon);\n};\n\nme.addIcon = function(mode){\n  var el = $('<div/>');\n  $(ME).append(el);\n  var ctl = {};\n  var s = mode == 'list' ? 0.05 : 0.1;\n  ctl.scale = new THREE.Vector3(s, s, s);\n  me.model.scene.viewer.add(el[0], \"flow\", mode+\"icon\", function(model){\n    //me.children.push(model);\n    me.icon = model.api;\n    model.api.parent = me;\n    me.sphere.rig.scale_x = 0.01;\n    me.sphere.rig.pos_y = 0;\n    if (mode == 'loop' && me.direction == 'src') me.icon.model.rig.rot_z = Math.PI; \n    me.icon.click = me.click;\n    me.icon.drag = me.drag;\n    me.icon.drop = me.drop;\n  }, ctl, me.model.group);\n};\n\nme.dirty = function(){\n  me.parent.dirty();\n  me.checkIcon();\n};\n\nme.delete = function(){\n  if (me.line) {\n    me.model.scene.remove(me.line);\n    me.line = null;\n  }\n  if (me.target){ \n    if (me.target.targets) {\n      var i = me.target.targets.indexOf(me);\n      if (i != -1) me.target.targets.splice(i,1);\n    }\n    me.target = null;\n  }\n  if (me.targets){\n    for (var i in me.targets){\n      var t = me.targets[i];\n      if (t.line) {\n        t.model.scene.remove(t.line);\n        t.line = null;\n      }\n      t.target = null;\n    }\n  }\n  \n  var i = me.parent.nodes.indexOf(me);\n  if (i != -1) me.parent.nodes.splice(i, 1);\n\n  //me.model.group.parent.remove(me.group);\n  //i = me.model.scene.viewer.models.indexOf(me.model);\n  //me.model.scene.viewer.models.splice(i,1);\n  //debugger;\n  me.model.scene.viewer.removeModel(me.sphere);\n  me.model.scene.viewer.removeModel(me);\n  me.parent.updateWidth();\n  $(ME).remove();\n};\n\nme.select = function() {\n  me.sphere.api.data.color = 0x0000ff;\n  me.sphere.api.rebuild();\n\n  if (!me.editor) {\n    me.editor = $(\"<div class='floweditor' />\");\n    $(ME).append(me.editor);\n    installControl(me.editor[0], \"flow\", \"node_editor\", function(api){\n      api.parent = me;\n      if (me.parent.parent.type == \"case\") me.editor.find('.node_mode_div').css('display', 'none');\n    }, ME.DATA);\n  }\n    \n  me.editor.css(\"display\", \"block\");\n  me.selected = true;\n};\n\nme.unselect = function() {\n  me.sphere.api.data.color = 0x00ff00;\n  me.sphere.api.rebuild();\n  me.editor.css(\"display\", \"none\");\n  me.selected = false;\n};\n\nme.click = function(event) {\n  var p = me.parent;\n  while (p.type != 'case') p = p.parent;\n  p.select(me);\n  event.handled = true;\n  return false;\n};\n\nme.drop = function(event, model){\n  if (!event.handled){\n    event.handled = true;\n    \n    if (event.shiftKey){\n      $(\"#\"+me.model.scene.viewer.UUID)[0].lastDrag = new Date().getTime();\n      var amsrc = me.direction == \"src\";\n\n      if (model && me.line && model.parent.type == \"node\" && me.direction != model.parent.direction) {\n//        me.line.geometry.vertices[amsrc ? 1 : 0].copy(model.models[0].localToWorld(new THREE.Vector3(0,0,0)));\n//        me.line.geometry.verticesNeedUpdate = true;\n        \n        var v1 = model.models[0].localToWorld(new THREE.Vector3(0,0,0));\n        var off = amsrc ? 3 : 0; \n        var p = me.line.geometry.attributes.position.array;\n        p[off+0] = v1.x;\n        p[off+1] = v1.y;\n        p[off+2] = v1.z;\n        me.line.geometry.attributes.position.needsUpdate = true;\n\n        var src = amsrc ? me : model.parent;\n        var dst = amsrc ? model.parent : me;\n\n        if (amsrc && dst.line){\n          me.model.scene.remove(dst.line);\n        }\n\n        if (amsrc && dst.target){\n          dst.target.targets.splice(dst.target.targets.indexOf(dst), 1);\n        }\n\n        dst.line = me.line;\n        dst.target = src;\n        src.line = null;\n        src.target = null;\n\n        if (!src.targets) src.targets = [];\n        if (src.targets.indexOf(dst) == -1) src.targets.push(dst);\n      }\n      else {\n        if (me.line) {\n          me.model.scene.remove(me.line);\n          me.line = null;\n        }\n        if (me.target){ \n          if (me.target.line) me.model.scene.remove(me.target.line);\n          me.target.target = null;\n          me.target.line = null;\n          me.target = null;\n        }\n      }\n    }\n  }\n  return false;\n};\n\nme.drag = function(event, x, y){\n  var pos = me.model.scene.viewer.to3D(event.clientX, event.clientY);\n  var amsrc = me.direction == \"src\";\n  \n  if (event.shiftKey && !event.handled){\n    event.handled = true;\n    $(\"#\"+me.model.scene.viewer.UUID)[0].lastDrag = new Date().getTime();\n    \n    if (!me.line){\n      var v1 = event.three.intersect.object.localToWorld(new THREE.Vector3(0,0,0));\n      var v2 = event.three.intersect.point.clone();\n      var srcV = amsrc ? v1 : v2;\n      var dstV = amsrc ? v2 : v1;\n//      var geometry = new THREE.Geometry();\n//      geometry.vertices.push(srcV, dstV);\n      \n      \n      var points = [];\n      points.push(\n        srcV,\n        dstV\n      );\n      var geometry = new THREE.BufferGeometry().setFromPoints( points );\n      \n      \n      var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );\n      var mesh = me.line = new THREE.Line( geometry, material );\n      me.model.scene.add(mesh);\n    }\n    \n    var v1 = event.three.drag;\n    var off = amsrc ? 3 : 0; \n    var p = me.line.geometry.attributes.position.array;\n    p[off+0] = v1.x;\n    p[off+1] = v1.y;\n    p[off+2] = v1.z;\n    me.line.geometry.attributes.position.needsUpdate = true;\n    \n    \n//    me.line.geometry.vertices[amsrc ? 1 : 0].copy(event.three.drag);\n//    me.line.geometry.verticesNeedUpdate = true;\n\n    return false;\n  }\n  else{\n    var m = me.model;\n    while (m && m.parent && m.parent.model.rig){\n      pos.x -= m.parent.model.rig.pos_x;\n      m = m.parent.model;\n    }\n    me.model.rig.pos_x = pos.x; \n    me.updateLines();\n    me.parent.updateWidth();\n    me.dirty();\n    \n    if (me.data.mode == 'loop' && me.data.loop) {\n      me.data.loop.model.rig.pos_x = pos.x;\n      me.data.loop.updateLines();\n      me.data.loop.parent.updateWidth();\n    }\n  }  \n};\n\nme.updateLines = function(){\n  var amsrc = me.direction == \"src\";\n  if (amsrc) {\n    if (!me.targets) me.targets = [];\n    for (var i in me.targets) me.targets[i].updateLine();\n  }\n  else me.updateLine();\n};\n\nme.updateLine = function(){\n  if (me.line) {\n//    me.line.geometry.vertices[0].copy(me.target.sphere.models[0].localToWorld(new THREE.Vector3(0,0,0)));\n//    me.line.geometry.vertices[1].copy(me.sphere.models[0].localToWorld(new THREE.Vector3(0,0,0)));\n//    me.line.geometry.verticesNeedUpdate = true;\n    \n    \n    \n    var v1 = me.target.sphere.models[0].localToWorld(new THREE.Vector3(0,0,0));\n    var v2 = me.sphere.models[0].localToWorld(new THREE.Vector3(0,0,0));\n    var p = me.line.geometry.attributes.position.array;\n    p[0] = v1.x;\n    p[1] = v1.y;\n    p[2] = v1.z;\n    p[3] = v2.x;\n    p[4] = v2.y;\n    p[5] = v2.z;\n    me.line.geometry.attributes.position.needsUpdate = true;\n\n  }\n};\n","groups":"anonymous","ctl":"plyktp178da9d0906s1b","html":"","three":{"controls":[{"color":"#00ff00","shape":"sphere","pos":{"x":0,"y":0,"z":0},"rot":{"x":0,"y":0,"z":0},"name":"orb","scale":{"x":"0.02","y":"0.02","z":"0.02"},"id":"hmzspn1682ebb4187udc6e","opacity":0.5,"uuid":"6aab996a-a3f0-414f-80da-d84186c9a0e8","db":"threejs"}]},"db":"flow","desc":""},"readers":["anonymous"],"id":"plyktp178da9d0906s1b","sessionid":"jvgvwg16b7a4d277bt3","time":1623676967787,"addr":"/0:0:0:0:0:0:0:1:55094","username":"admin"}
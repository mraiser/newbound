{"data":{"css":"","data":[],"name":"orb_motion","js":"var me = this;\nvar ME = $('#'+me.UUID)[0];\n\nvar zero = new THREE.Vector3( 0, 0, 0 );\nvar lines = {};\nvar lastcheck = 0;\n\nme.animate = function(model){\n  var rig = model.rig;\n  var animations = model.animations;\n  var camera = model.scene.camera;\n  \n  var cons = null;\n\n  function addLine(start, stop, color){\n    console.log('adding a line...');\n      var material = new THREE.LineBasicMaterial({\n          color: color\n      });\n\n      var geometry = new THREE.Geometry();\n      geometry.vertices.push(\n          start,\n          stop\n      );\n\n      var line = new THREE.Line( geometry, material );\n      model.scene.add( line );\n\n    return line;\n  }\n\n  function addText(text, pos, font, color){\n    var textMaterial = new THREE.MeshPhongMaterial( \n      { color: color, specular: 0xffffff }\n    );\n\n    var textGeometry = buildTextGeo(text, font);\n    THREE.GeometryUtils.center( textGeometry )\n\n    var mesh = new THREE.Mesh( textGeometry, textMaterial );\n    mesh.position.copy(pos);\n    mesh.scale.x = 0.001;\n    mesh.scale.y = 0.001;\n    mesh.scale.z = 0.001;\n    model.scene.add( mesh );\n\n    return mesh;\n  }\n\n  if (false && $(ME).data('peer').connected){\n    var start = new THREE.Vector3( rig.pos_x, rig.pos_y, rig.pos_z );\n    me.line = addLine(start, zero, 0xff0000);\n  }\n  \n  animations.push(function(model){\n    debugger;\n    var name = $(ME).data('peer').name;\n    if (me.text3d && me.lastname != name) {\n      model.scene.remove( me.text3d );\n      me.text3d = null;\n    }\n    if (!me.text3d) {\n      me.text3d = model.text3d = addText(name, new THREE.Vector3( rig.pos_x, rig.pos_y, rig.pos_z ), font, 0xFFFFFF); \n      me.lastname = name;\n    }\n    \n    var p = $(ME).data('peer');\n\n    var c = model.models[0] ? model.models[0].material[0].color : {};\n    if (p.connected) {\n//      console.log(p.millis);\n      c.b = Math.max(0, Math.min(1, (p.millis - 10000)/10000)); //p.millis < 10000 ? 0 : 0.5;\n      c.g = 0.403921568627451;\n      c.r = p.tcp ? 0.1843137254901961 :  0.4;\n    }\n    else{\n      c.b = 0.5;\n      c.g = 0.5;\n      c.r = 0.5;\n      cons = null;\n    }\n    \n    rig.rot_y += 0.01;\n    \n    var a = new THREE.Vector3( rig.pos_x, rig.pos_y, rig.pos_z );\n    var l = a.distanceTo(zero);\n    \n    if (p.connected){\n      if (l>2){\n        var d = 0.999;\n        rig.pos_x *= d;\n        rig.pos_y *= d;\n        rig.pos_z *= d;\n      }\n    }\n    else{\n      if (l<10){\n        var d = 1.001;\n        rig.pos_x *= d;\n        rig.pos_y *= d;\n        rig.pos_z *= d;\n      }\n      for (var id in lines){\n        model.scene.remove(lines[id]);\n        delete lines[id];\n      }\n    }\n    \n    var v1 = new THREE.Vector3( rig.pos_x, rig.pos_y, rig.pos_z );\n    \n    $('.peerorb').each(function(x, el2){\n      if (el2.id != p.id && el2.api && el2.api.rig){\n        var p2 = cons ? cons[el2.id] : null;\n        var rig2 = el2.api.rig;\n        var v2 = new THREE.Vector3( rig2.pos_x, rig2.pos_y, rig2.pos_z );\n\n        var l = v1.distanceTo(v2);\n        var d = v2.clone();\n        d.sub(v1);\n        d.normalize();\n        d.multiplyScalar(0.01);\n\n        if (l<2) {\n          v1.sub(d)\n        }\n        else {\n          if (l>4 && p2 && p2.connected) v1.add(d);\n        }\n\n        rig.pos_x = v1.x;\n        rig.pos_y = v1.y;\n        rig.pos_z = v1.z;\n        \n        if (p2 && p2.connected){\n//          var c = p2.tcp ? 0x00ffff : 0x0000ff;\n          if (lines[el2.id]){\n            lines[el2.id].geometry.vertices[0] = v1;\n            lines[el2.id].geometry.vertices[1] = v2;\n            lines[el2.id].geometry.verticesNeedUpdate = true;\n            lines[el2.id].material.color.r = p2.tcp ? 0 : 0.4;\n            lines[el2.id].material.color.g = 0.4;\n//            lines[el2.id].material.color.b = 0;\n//            debugger;\n            lines[el2.id].material.color.b = p.oldlastcontact == p.lastcontact ? 0 : 1;\n            p.oldlastcontact = p.lastcontact;\n//            lines[el2.id].material.color.r = Math.random();\n          }\n          else {\n            lines[el2.id] = addLine(v1, v2, c);\n          }\n        }\n        else if (lines[el2.id]){\n          model.scene.remove(lines[el2.id]);\n          delete lines[el2.id];\n        }\n      }\n    });\n    \n    if (me.line) {\n      var v = me.line.geometry.vertices[0];\n      v.x = rig.pos_x;\n      v.y = rig.pos_y;\n      v.z = rig.pos_z;\n      me.line.geometry.verticesNeedUpdate = true;\n//      me.line.updateMatrix();\n    }\n    \n    if (me.text3d) {\n      me.text3d.position.copy(v1);\n      me.text3d.position.y += 0.3;\n      me.text3d.rotation.copy(camera.rotation);\n    }\n    \n    var now = new Date().getTime();\n//    if (NUMREMOTECHECKS < 2 && now - lastcheck > 10000 && cons == null && $(ME).data('peer').connected) {\n    if (now - lastcheck > 10000 && $(ME).data('peer').connected) {\n      lastcheck = now;\n//      NUMREMOTECHECKS++;\n      json('../peerbot/remote/'+$(ME).data('peer').id+'/peerbot/lookup', 'uuids='+encodeURIComponent(document.body.ALLPEERIDS), function(result){\n//        NUMREMOTECHECKS--;\n        cons = result;\n      });\n    }\n    \n    \n  });\n};\n\n//NUMREMOTECHECKS = 0;\n\nfunction distanceVector( v1, v2 )\n{\n    var dx = v1.x - v2.x;\n    var dy = v1.y - v2.y;\n    var dz = v1.z - v2.z;\n\n    return Math.sqrt( dx * dx + dy * dy + dz * dz );\n}\n\nfunction buildTextGeo(text, font){\n    var textGeo = new THREE.TextGeometry( text, {\n\t\tfont: font,\n\t\tsize: 80,\n\t\theight: 5,\n\t\tcurveSegments: 12,\n\t\tbevelEnabled: false,\n\t\tbevelThickness: 10,\n\t\tbevelSize: 8,\n\t\tbevelSegments: 5\n\t} );\n    return textGeo;\n}\n\n\n\n","groups":"anonymous","ctl":"oshlom162582ca334i16f","html":"","three":{"controls":[]},"db":"peerbot","desc":""},"readers":["anonymous"],"id":"oshlom162582ca334i16f","sessionid":"jvgvwg16b7a4d277bt3","time":1575048060129,"addr":"/0:0:0:0:0:0:0:1:54580","username":"admin"}